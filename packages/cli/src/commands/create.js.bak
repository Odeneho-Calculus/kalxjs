const fs = require('fs-extra');
const path = require('path');
const validateProjectName = require('validate-npm-package-name');
const chalk = require('chalk');
const ora = require('ora');
const inquirer = require('inquirer');
const deepmerge = require('deepmerge');
const execa = require('execa');

async function create(projectName, options = {}) {
  // Validate project name
  const result = validateProjectName(projectName);
  if (!result.validForNewPackages) {
    console.error(chalk.red(`Invalid project name: "${projectName}"`));
    result.errors && result.errors.forEach(err => {
      console.error(chalk.red.dim('Error: ' + err));
    });
    result.warnings && result.warnings.forEach(warn => {
      console.error(chalk.yellow.dim('Warning: ' + warn));
    });
    process.exit(1);
  }

  const cwd = options.cwd || process.cwd();
  const targetDir = path.resolve(cwd, projectName);

  if (fs.existsSync(targetDir)) {
    console.error(chalk.red(`Directory ${projectName} already exists.`));
    process.exit(1);
  }

  const spinner = ora(`Creating project in ${chalk.cyan(targetDir)}...`).start();

  try {
    // Create project directory
    await fs.ensureDir(targetDir);

    // Stop spinner during prompts
    spinner.stop();

    // Get feature flags
    const promptAnswers = options.default ? {
      router: true,
      state: true,
      scss: true,
      testing: true,
      linting: true,
      sfc: true,
      ai: false,
      api: true,
      composition: true,
      performance: true,
      plugins: true
    } : await inquirer.prompt([
      {
        type: 'confirm',
        name: 'router',
        message: 'Add Router support?',
        default: true
      },
      {
        type: 'confirm',
        name: 'state',
        message: 'Add State Management?',
        default: true
      },
      {
        type: 'confirm',
        name: 'scss',
        message: 'Add SCSS support?',
        default: true
      },
      {
        type: 'confirm',
        name: 'sfc',
        message: 'Add Single File Components support?',
        default: true
      },
      {
        type: 'confirm',
        name: 'composition',
        message: 'Add Composition API support?',
        default: true
      },
      {
        type: 'confirm',
        name: 'api',
        message: 'Add API integration utilities?',
        default: true
      },
      {
        type: 'confirm',
        name: 'performance',
        message: 'Add Performance optimization utilities?',
        default: true
      },
      {
        type: 'confirm',
        name: 'plugins',
        message: 'Add Plugin system support?',
        default: true
      },
      {
        type: 'confirm',
        name: 'ai',
        message: 'Add AI features support?',
        default: false
      },
      {
        type: 'confirm',
        name: 'testing',
        message: 'Add Testing setup?',
        default: true
      },
      {
        type: 'confirm',
        name: 'linting',
        message: 'Add ESLint setup?',
        default: true
      }
    ]);

    // Create a new config object
    const projectConfig = deepmerge({
      projectName,
      features: promptAnswers
    }, options);

    spinner.start();

    // Generate project files
    await generateProject(targetDir, projectConfig);

    // Process template files
    spinner.text = 'Processing templates...';
    await processTemplates(targetDir, projectConfig);

    // Install dependencies
    if (!options.skipInstall) {
      spinner.text = 'Installing dependencies...';
      await installDependencies(targetDir, projectConfig);
    }

    spinner.succeed(`Project created successfully at ${chalk.cyan(targetDir)}`);

    // Show next steps
    console.log('\n  Done. Now run:\n');
    console.log(chalk.cyan(`  cd ${projectName}`));
    if (options.skipInstall) console.log(chalk.cyan('  npm install'));
    console.log(chalk.cyan('  npm run dev\n'));

  } catch (err) {
    spinner.fail('Project creation failed.');
    console.error(chalk.red(err.stack || err.message));

    // Cleanup on failure
    if (fs.existsSync(targetDir)) {
      fs.removeSync(targetDir);
    }

    process.exit(1);
  }
}

async function generateProject(targetDir, config) {
  // Create basic structure
  const dirs = [
    'src',
    'src/components',
    'src/assets',
    'public',
    config.features.router && 'src/views',
    config.features.router && 'src/router',
    config.features.state && 'src/store',
    config.features.scss && 'src/styles',
    config.features.sfc && 'src/components/sfc',
    config.features.ai && 'src/ai',
    config.features.api && 'src/api',
    config.features.composition && 'src/composables',
    config.features.performance && 'src/utils/performance',
    config.features.plugins && 'src/plugins'
  ].filter(Boolean);

  for (const dir of dirs) {
    await fs.ensureDir(path.join(targetDir, dir));
  }

  // Create base files
  const files = {
    'public/.gitkeep': '',
    'src/assets/.gitkeep': '',
    'src/components/.gitkeep': '',
    ...(config.features.sfc ? { 'src/components/sfc/.gitkeep': '' } : {}),
    ...(config.features.ai ? { 'src/ai/.gitkeep': '' } : {}),
    ...(config.features.api ? { 'src/api/.gitkeep': '' } : {}),
    ...(config.features.composition ? { 'src/composables/.gitkeep': '' } : {}),
    ...(config.features.performance ? { 'src/utils/performance/.gitkeep': '' } : {}),
    ...(config.features.plugins ? { 'src/plugins/.gitkeep': '' } : {})
  };

  // Add API integration example if enabled
  if (config.features.api) {
    files['src/api/useApi.js'] = `import { ref, reactive, computed } from '@kalxjs/core';

/**
 * Custom hook for API requests with built-in state management
 * @param {Object} options - Configuration options
 * @param {string} options.baseUrl - Base URL for API requests
 * @param {Object} options.headers - Default headers for requests
 * @param {number} options.timeout - Request timeout in milliseconds
 * @param {Function} options.onError - Global error handler
 * @returns {Object} API utilities and state
 */
export function useApi(options = {}) {
  const {
    baseUrl = '',
    headers: defaultHeaders = { 'Content-Type': 'application/json' },
    timeout = 30000,
    onError = null
  } = options;

  // State
  const isLoading = ref(false);
  const error = ref(null);
  const abortControllers = reactive({});

  // Computed
  const hasError = computed(() => error.value !== null);

  /**
   * Make an API request
   * @param {Object} config - Request configuration
   * @returns {Promise} - Response promise
   */
  async function request(config) {
    const {
      url,
      method = 'GET',
      data = null,
      params = {},
      headers = {},
      signal = null,
      cache = 'default',
      key = url + method
    } = config;

    // Create URL with query parameters
    const queryParams = new URLSearchParams();
    Object.entries(params).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        queryParams.append(key, value);
      }
    });

    const fullUrl = \`\${baseUrl}\${url}\${queryParams.toString() ? '?' + queryParams.toString() : ''}\`;

    // Create abort controller if not provided
    let controller;
    if (signal) {
      controller = { signal };
    } else {
      controller = new AbortController();
      abortControllers[key] = controller;
    }

    // Reset state
    isLoading.value = true;
    error.value = null;

    try {
      // Prepare request options
      const requestOptions = {
        method,
        headers: { ...defaultHeaders, ...headers },
        signal: controller.signal,
        cache
      };

      // Add body for non-GET requests
      if (method !== 'GET' && data) {
        requestOptions.body = typeof data === 'string' ? data : JSON.stringify(data);
      }

      // Set timeout
      const timeoutId = setTimeout(() => {
        if (abortControllers[key]) {
          abortControllers[key].abort();
          delete abortControllers[key];
        }
      }, timeout);

      // Make request
      const response = await fetch(fullUrl, requestOptions);
      clearTimeout(timeoutId);

      // Handle response
      if (!response.ok) {
        throw new Error(\`API error: \${response.status} \${response.statusText}\`);
      }

      // Parse response based on content type
      const contentType = response.headers.get('content-type');
      let result;

      if (contentType && contentType.includes('application/json')) {
        result = await response.json();
      } else if (contentType && contentType.includes('text/')) {
        result = await response.text();
      } else {
        result = await response.blob();
      }

      return result;
    } catch (err) {
      error.value = err.message || 'Unknown error occurred';

      if (onError && typeof onError === 'function') {
        onError(err);
      }

      throw err;
    } finally {
      isLoading.value = false;
      if (abortControllers[key]) {
        delete abortControllers[key];
      }
    }
  }

  /**
   * Abort an ongoing request
   * @param {string} key - Request key to abort
   */
  function abort(key) {
    if (abortControllers[key]) {
      abortControllers[key].abort();
      delete abortControllers[key];
    }
  }

  /**
   * Abort all ongoing requests
   */
  function abortAll() {
    Object.values(abortControllers).forEach(controller => {
      controller.abort();
    });
    Object.keys(abortControllers).forEach(key => {
      delete abortControllers[key];
    });
  }

  // Convenience methods
  const get = (url, config = {}) => request({ ...config, url, method: 'GET' });
  const post = (url, data, config = {}) => request({ ...config, url, method: 'POST', data });
  const put = (url, data, config = {}) => request({ ...config, url, method: 'PUT', data });
  const patch = (url, data, config = {}) => request({ ...config, url, method: 'PATCH', data });
  const del = (url, config = {}) => request({ ...config, url, method: 'DELETE' });

  return {
    // State
    isLoading,
    error,
    hasError,

    // Methods
    request,
    get,
    post,
    put,
    patch,
    delete: del,
    abort,
    abortAll
  };
}`;
  }

  // Add Composition API example if enabled
  if (config.features.composition) {
    files['src/composables/useWindowSize.js'] = `import { ref, onMounted, onUnmounted } from '@kalxjs/core';

/**
 * Composable for tracking window size
 * @returns {Object} Window size state and utilities
 */
export function useWindowSize() {
  const width = ref(window.innerWidth);
  const height = ref(window.innerHeight);

  // Computed breakpoints
  const isMobile = ref(width.value < 768);
  const isTablet = ref(width.value >= 768 && width.value < 1024);
  const isDesktop = ref(width.value >= 1024);

  function updateSize() {
    width.value = window.innerWidth;
    height.value = window.innerHeight;

    // Update breakpoints
    isMobile.value = width.value < 768;
    isTablet.value = width.value >= 768 && width.value < 1024;
    isDesktop.value = width.value >= 1024;
  }

  onMounted(() => {
    window.addEventListener('resize', updateSize);
  });

  onUnmounted(() => {
    window.removeEventListener('resize', updateSize);
  });

  return {
    width,
    height,
    isMobile,
    isTablet,
    isDesktop
  };
}`;

    files['src/composables/useLocalStorage.js'] = `import { ref, watch } from '@kalxjs/core';

/**
 * Composable for using localStorage with reactivity
 * @param {string} key - localStorage key
 * @param {any} defaultValue - Default value if key doesn't exist
 * @returns {Object} Reactive value and utilities
 */
export function useLocalStorage(key, defaultValue = null) {
  // Get initial value from localStorage or use default
  const getStoredValue = () => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error(\`Error reading localStorage key "\${key}":\`, error);
      return defaultValue;
    }
  };

  const storedValue = ref(getStoredValue());

  // Update localStorage when value changes
  watch(storedValue, (newValue) => {
    try {
      if (newValue === null || newValue === undefined) {
        window.localStorage.removeItem(key);
      } else {
        window.localStorage.setItem(key, JSON.stringify(newValue));
      }
    } catch (error) {
      console.error(\`Error writing to localStorage key "\${key}":\`, error);
    }
  });

  // Handle storage events from other tabs/windows
  const handleStorageChange = (event) => {
    if (event.key === key) {
      storedValue.value = event.newValue ? JSON.parse(event.newValue) : defaultValue;
    }
  };

  // Add event listener for storage events
  window.addEventListener('storage', handleStorageChange);

  // Remove event listener on cleanup
  const clear = () => {
    window.removeEventListener('storage', handleStorageChange);
  };

  return {
    value: storedValue,
    clear,
    remove: () => {
      window.localStorage.removeItem(key);
      storedValue.value = defaultValue;
    }
  };
}`;
  }

  // Add Performance utilities if enabled
  if (config.features.performance) {
    files['src/utils/performance/lazyLoad.js'] = `import { ref, onMounted } from '@kalxjs/core';

/**
 * Utility for lazy loading components or resources
 * @param {Function} importFn - Dynamic import function
 * @param {Object} options - Configuration options
 * @returns {Object} Lazy loading state and component
 */
export function useLazyLoad(importFn, options = {}) {
  const {
    immediate = false,
    loadingComponent = null,
    errorComponent = null,
    onError = null
  } = options;

  const component = ref(loadingComponent);
  const isLoading = ref(immediate);
  const isLoaded = ref(false);
  const error = ref(null);

  const load = async () => {
    if (isLoaded.value || isLoading.value) return;

    isLoading.value = true;
    error.value = null;

    try {
      const loadedModule = await importFn();
      component.value = loadedModule.default || loadedModule;
      isLoaded.value = true;
    } catch (err) {
      error.value = err;
      component.value = errorComponent;

      if (onError && typeof onError === 'function') {
        onError(err);
      }
    } finally {
      isLoading.value = false;
    }
  };

  if (immediate) {
    // Load immediately if specified
    load();
  }

  onMounted(() => {
    // Check if component should be loaded on mount
    if (!immediate && !isLoaded.value) {
      load();
    }
  });

  return {
    component,
    isLoading,
    isLoaded,
    error,
    load
  };
}`;

    files['src/utils/performance/debounce.js'] = `/**
 * Creates a debounced function that delays invoking the provided function
 * until after the specified wait time has elapsed since the last invocation.
 *
 * @param {Function} func - The function to debounce
 * @param {number} wait - The number of milliseconds to delay
 * @param {Object} options - The options object
 * @param {boolean} options.leading - Specify invoking on the leading edge of the timeout
 * @param {boolean} options.trailing - Specify invoking on the trailing edge of the timeout
 * @returns {Function} The debounced function
 */
export function debounce(func, wait = 300, options = {}) {
  const { leading = false, trailing = true } = options;

  let timeout;
  let result;
  let lastArgs;
  let lastThis;
  let lastCallTime = 0;
  let lastInvokeTime = 0;
  let isInvoking = false;

  // Convert wait to number if it's not already
  const waitTime = +wait || 0;

  function invokeFunc(time) {
    const args = lastArgs;
    const thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    isInvoking = true;

    result = func.apply(thisArg, args);
    isInvoking = false;

    return result;
  }

  function leadingEdge(time) {
    lastInvokeTime = time;
    // Schedule a trailing edge call
    timeout = setTimeout(timerExpired, waitTime);
    // Invoke the leading edge
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;
    const timeWaiting = waitTime - timeSinceLastCall;

    return trailing ? Math.min(timeWaiting, waitTime - timeSinceLastInvoke) : timeWaiting;
  }

  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    const timeSinceLastInvoke = time - lastInvokeTime;

    return (
      lastCallTime === undefined || // First call
      timeSinceLastCall >= waitTime || // Wait time elapsed
      timeSinceLastCall < 0 || // System time adjusted
      (trailing && timeSinceLastInvoke >= waitTime) // Trailing edge case
    );
  }

  function timerExpired() {
    const time = Date.now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }

    // Restart the timer
    timeout = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timeout = undefined;

    // Only invoke if we have lastArgs, which means func has been called at least once
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timeout !== undefined) {
      clearTimeout(timeout);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timeout = undefined;
  }

  function flush() {
    return timeout === undefined ? result : trailingEdge(Date.now());
  }

  function pending() {
    return timeout !== undefined;
  }

  function debounced(...args) {
    const time = Date.now();
    const isInvoking = shouldInvoke(time);

    lastArgs = args;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timeout === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (isInvoking) {
        // Handle invocations in a tight loop
        clearTimeout(timeout);
        timeout = setTimeout(timerExpired, waitTime);
        return invokeFunc(lastCallTime);
      }
    }

    if (timeout === undefined) {
      timeout = setTimeout(timerExpired, waitTime);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  debounced.pending = pending;

  return debounced;
}`;
  }

  // Add Plugin system example if enabled
  if (config.features.plugins) {
    files['src/plugins/index.js'] = `import { createApp } from '@kalxjs/core';

/**
 * Plugin system for extending application functionality
 */
export const plugins = {
  _registry: new Map(),
  _hooks: new Map(),

  /**
   * Register a plugin
   * @param {string} name - Plugin name
   * @param {Object} plugin - Plugin object
   * @param {Object} options - Plugin options
   */
  register(name, plugin, options = {}) {
    if (this._registry.has(name)) {
      console.warn(\`Plugin "\${name}" is already registered. It will be overwritten.\`);
    }

    this._registry.set(name, { plugin, options });

    // Initialize plugin if it has an install method
    if (plugin.install && typeof plugin.install === 'function') {
      plugin.install(options);
    }

    return this;
  },

  /**
   * Get a registered plugin
   * @param {string} name - Plugin name
   * @returns {Object|null} Plugin object or null if not found
   */
  get(name) {
    const entry = this._registry.get(name);
    return entry ? entry.plugin : null;
  },

  /**
   * Check if a plugin is registered
   * @param {string} name - Plugin name
   * @returns {boolean} True if plugin is registered
   */
  has(name) {
    return this._registry.has(name);
  },

  /**
   * Unregister a plugin
   * @param {string} name - Plugin name
   */
  unregister(name) {
    const entry = this._registry.get(name);

    if (entry && entry.plugin.uninstall && typeof entry.plugin.uninstall === 'function') {
      entry.plugin.uninstall();
    }

    this._registry.delete(name);
    return this;
  },

  /**
   * Register a hook
   * @param {string} name - Hook name
   * @param {Function} callback - Hook callback
   * @param {Object} options - Hook options
   */
  hook(name, callback, options = {}) {
    if (!this._hooks.has(name)) {
      this._hooks.set(name, []);
    }

    this._hooks.get(name).push({ callback, options });
    return this;
  },

  /**
   * Execute a hook
   * @param {string} name - Hook name
   * @param {...any} args - Arguments to pass to hook callbacks
   * @returns {Promise<Array>} Results from hook callbacks
   */
  async executeHook(name, ...args) {
    if (!this._hooks.has(name)) {
      return [];
    }

    const hooks = this._hooks.get(name);
    const results = [];

    for (const hook of hooks) {
      try {
        const result = await hook.callback(...args);
        results.push(result);
      } catch (error) {
        console.error(\`Error executing hook "\${name}":\`, error);
        if (hook.options.throwError) {
          throw error;
        }
      }
    }

    return results;
  },

  /**
   * Apply all plugins to an app instance
   * @param {Object} app - App instance
   */
  applyToApp(app) {
    for (const [name, entry] of this._registry.entries()) {
      if (entry.plugin.applyToApp && typeof entry.plugin.applyToApp === 'function') {
        entry.plugin.applyToApp(app, entry.options);
      }
    }

    return app;
  }
};

/**
 * Create a plugin
 * @param {Object} options - Plugin configuration
 * @returns {Object} Plugin object
 */
export function createPlugin(options) {
  const {
    name,
    install,
    uninstall,
    applyToApp,
    hooks = {},
    ...rest
  } = options;

  const plugin = {
    name,
    install,
    uninstall,
    applyToApp,
    ...rest
  };

  // Register hooks
  Object.entries(hooks).forEach(([hookName, callback]) => {
    plugins.hook(hookName, callback);
  });

  return plugin;
}`;

    files['src/plugins/logger.js'] = `import { createPlugin } from './index';

/**
 * Logger plugin for application-wide logging
 */
export const loggerPlugin = createPlugin({
  name: 'logger',

  // Plugin state
  _config: {
    level: 'info',
    prefix: '[App]',
    enabled: true,
    console: true,
    custom: null
  },

  // Log levels
  levels: {
    debug: 0,
    info: 1,
    warn: 2,
    error: 3
  },

  /**
   * Install the plugin
   * @param {Object} options - Plugin options
   */
  install(options = {}) {
    this._config = { ...this._config, ...options };

    // Register global error handler if enabled
    if (this._config.catchErrors) {
      window.addEventListener('error', (event) => {
        this.error('Uncaught error:', event.error);
      });

      window.addEventListener('unhandledrejection', (event) => {
        this.error('Unhandled promise rejection:', event.reason);
      });
    }
  },

  /**
   * Apply plugin to app instance
   * @param {Object} app - App instance
   * @param {Object} options - Plugin options
   */
  applyToApp(app, options = {}) {
    // Add logger to app instance
    app.logger = this;

    // Add logger to app context
    app.provide('logger', this);
  },

  /**
   * Check if a log level is enabled
   * @param {string} level - Log level
   * @returns {boolean} True if level is enabled
   */
  isLevelEnabled(level) {
    return this._config.enabled &&
           this.levels[level] >= this.levels[this._config.level];
  },

  /**
   * Format log message
   * @param {string} level - Log level
   * @param {Array} args - Log arguments
   * @returns {Array} Formatted log arguments
   */
  formatLog(level, args) {
    const timestamp = new Date().toISOString();
    const prefix = this._config.prefix;
    return [\`\${prefix} [\${timestamp}] [\${level.toUpperCase()}]\`, ...args];
  },

  /**
   * Log a message
   * @param {string} level - Log level
   * @param {...any} args - Log arguments
   */
  log(level, ...args) {
    if (!this.isLevelEnabled(level)) return;

    const formattedArgs = this.formatLog(level, args);

    // Console logging
    if (this._config.console) {
      switch (level) {
        case 'debug':
          console.debug(...formattedArgs);
          break;
        case 'info':
          console.info(...formattedArgs);
          break;
        case 'warn':
          console.warn(...formattedArgs);
          break;
        case 'error':
          console.error(...formattedArgs);
          break;
        default:
          console.log(...formattedArgs);
      }
    }

    // Custom logger
    if (this._config.custom && typeof this._config.custom === 'function') {
      this._config.custom(level, formattedArgs);
    }
  },

  // Convenience methods
  debug(...args) { this.log('debug', ...args); },
  info(...args) { this.log('info', ...args); },
  warn(...args) { this.log('warn', ...args); },
  error(...args) { this.log('error', ...args); },

  /**
   * Set log level
   * @param {string} level - Log level
   */
  setLevel(level) {
    if (this.levels[level] !== undefined) {
      this._config.level = level;
    }
  },

  /**
   * Enable or disable logging
   * @param {boolean} enabled - Whether logging is enabled
   */
  setEnabled(enabled) {
    this._config.enabled = !!enabled;
  }
});`;
  }

  // Add SFC example component if enabled
  if (config.features.sfc) {
    files['src/components/sfc/Card.klx'] = `<template>
  <div class="card">
    <div class="card-header">
      <slot name="header">Default Header</slot>
    </div>
    <div class="card-body">
      <slot>Default Content</slot>
    </div>
    <div class="card-footer">
      <slot name="footer">Default Footer</slot>
    </div>
  </div>
</template>

<script>
import { defineComponent } from '@kalxjs/core';

export default defineComponent({
  name: 'Card',
  props: {
    title: String,
    subtitle: String,
    bordered: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    // Component logic here
    return {};
  }
});
</script>

<style>
.card {
  border-radius: 8px;
  overflow: hidden;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  margin-bottom: 1rem;
  background-color: white;
}

.card-header {
  padding: 1rem;
  border-bottom: 1px solid #e2e8f0;
  font-weight: bold;
}

.card-body {
  padding: 1rem;
}

.card-footer {
  padding: 1rem;
  border-top: 1px solid #e2e8f0;
  background-color: #f8f9fa;
}
</style>`;
  }

  // Add AI manager example if enabled
  if (config.features.ai) {
    files['src/ai/aiManager.js'] = `import { createAIManager } from '@kalxjs/core';

// Create and export the AI manager instance
export const aiManager = createAIManager({
  apiKeys: {
    // Add your API keys here
    huggingface: process.env.HUGGINGFACE_API_KEY || '',
    openai: process.env.OPENAI_API_KEY || ''
  },
  defaultProvider: 'huggingface',
  defaultOptions: {
    // Default options for AI requests
    temperature: 0.7,
    max_length: 100
  }
});

// Helper functions for common AI tasks
export async function generateText(prompt, options = {}) {
  return aiManager.generateText({
    prompt,
    model: options.model || 'gpt2',
    provider: options.provider || 'huggingface',
    options: {
      ...options
    }
  });
}

export async function generateImage(prompt, options = {}) {
  return aiManager.generateImage({
    prompt,
    model: options.model || 'stabilityai/stable-diffusion-2',
    provider: options.provider || 'huggingface',
    options: {
      negative_prompt: options.negativePrompt || 'blurry, bad quality',
      num_inference_steps: options.steps || 30,
      guidance_scale: options.guidance || 7.5,
      ...options
    }
  });
}`;

    files['src/components/AITextGenerator.js'] = `import { defineComponent, h, ref } from '@kalxjs/core';
import { generateText } from '../ai/aiManager';

export default defineComponent({
  name: 'AITextGenerator',
  props: {
    initialPrompt: String,
    placeholder: {
      type: String,
      default: 'Enter your prompt here...'
    }
  },
  setup(props) {
    const prompt = ref(props.initialPrompt || '');
    const result = ref('');
    const loading = ref(false);
    const error = ref(null);

    const generateContent = async () => {
      if (!prompt.value) return;

      loading.value = true;
      error.value = null;

      try {
        result.value = await generateText(prompt.value);
      } catch (err) {
        error.value = err.message || 'Failed to generate text';
        console.error('AI text generation error:', err);
      } finally {
        loading.value = false;
      }
    };

    return {
      prompt,
      result,
      loading,
      error,
      generateContent
    };
  },
  render() {
    return h('div', { class: 'ai-text-generator' }, [
      h('div', { class: 'input-group' }, [
        h('textarea', {
          value: this.prompt,
          onInput: (e) => this.prompt = e.target.value,
          placeholder: this.placeholder,
          rows: 3,
          style: 'width: 100%; padding: 0.5rem; border-radius: 4px; border: 1px solid #e2e8f0;'
        })
      ]),

      h('div', { class: 'controls', style: 'margin-top: 1rem;' }, [
        h('button', {
          onClick: this.generateContent,
          disabled: this.loading || !this.prompt,
          style: \`
            padding: 0.5rem 1rem;
            background-color: #4299e1;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: \${this.loading || !this.prompt ? 'not-allowed' : 'pointer'};
            opacity: \${this.loading || !this.prompt ? 0.7 : 1};
          \`
        }, this.loading ? 'Generating...' : 'Generate Text')
      ]),

      this.error && h('div', {
        class: 'error',
        style: 'margin-top: 1rem; color: #e53e3e; padding: 0.5rem; background-color: #fff5f5; border-radius: 4px;'
      }, this.error),

      this.result && h('div', {
        class: 'result',
        style: 'margin-top: 1rem; padding: 1rem; background-color: #f7fafc; border-radius: 4px; border: 1px solid #e2e8f0;'
      }, this.result)
    ]);
  }
});`;
  }

  files['src/components/Button.js'] = `import { defineComponent, h } from '@kalxjs/core';

export default defineComponent({
  name: 'Button',
  props: {
    text: String,
    primary: Boolean,
    onClick: Function
  },
  setup(props) {
    const getStyle = () => {
      const baseStyle = 'padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer; font-size: 1rem;';
      const colorStyle = props.primary
        ? 'background-color: #4299e1; color: white;'
        : 'background-color: #e2e8f0; color: #4a5568;';
      return baseStyle + colorStyle;
    };

    return { getStyle };
  },
  render() {
    return h('button', {
      style: this.getStyle(),
      onclick: this.onClick
    }, this.text || this.$slots.default);
  }
});`;

  files['.gitignore'] = `# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?`;

  files['README.md'] = `# ${config.projectName}

A modern web application built with KalxJS.

## Getting Started

\`\`\`bash
# Install dependencies
npm install

# Start development server
npm run dev

# Build for production
npm run build

# Preview production build
npm run preview
\`\`\`

## Features

${config.features.router ? '- Router for navigation\n' : ''}${config.features.state ? '- State management\n' : ''}${config.features.scss ? '- SCSS styling\n' : ''}${config.features.testing ? '- Testing setup\n' : ''}${config.features.linting ? '- ESLint for code quality\n' : ''}

## Project Structure

\`\`\`
${config.projectName}/
â”œâ”€â”€ public/          # Static assets
â”œâ”€â”€ src/             # Source code
â”‚   â”œâ”€â”€ assets/      # Project assets
â”‚   â”œâ”€â”€ components/  # UI components
${config.features.router ? 'â”‚   â”œâ”€â”€ views/       # Page components\nâ”‚   â”œâ”€â”€ router/      # Router configuration\n' : ''}${config.features.state ? 'â”‚   â”œâ”€â”€ store/       # State management\n' : ''}${config.features.scss ? 'â”‚   â”œâ”€â”€ styles/      # SCSS styles\n' : ''}â”‚   â”œâ”€â”€ App.js       # Root component
â”‚   â””â”€â”€ main.js      # Application entry point
â”œâ”€â”€ index.html       # HTML template
â””â”€â”€ vite.config.js   # Vite configuration
\`\`\`

## License

MIT`;

  files['index.html'] = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" type="image/svg+xml"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸš€</text></svg>" />
  <title>${config.projectName}</title>
</head>
<body>
  <div id="app"></div>
  <script type="module" src="/src/main.js"></script>
</body>
</html>`;

  files['src/main.js'] = `import { createApp } from '@kalxjs/core';
import App from './App.js';
${config.features.router ? "import router from './router';" : ''}
${config.features.state ? "import store from './store';" : ''}
${config.features.scss ? "import './styles/main.scss';" : ''}

try {
  const app = createApp(App);
  ${config.features.router ? 'app.use(router);' : ''}
  ${config.features.state ? 'app.use(store);' : ''}

  app.mount('#app');
  console.log('Application successfully mounted');
} catch (error) {
  console.error('Error initializing app:', error);

  // Fallback rendering in case of error
  document.getElementById('app').innerHTML = \`
    <div class="app" style="padding: 2rem; text-align: center;">
      <h1>Welcome to KalxJS</h1>
      <p>There was an error initializing the application.</p>
      <pre style="text-align: left; background: #f5f5f5; padding: 1rem; border-radius: 4px;">\${error.message}</pre>
    </div>
  \`;
}`;

  files['src/App.js'] = `import { defineComponent, h } from '@kalxjs/core';
${config.features.router ? "import { useRouter } from '@kalxjs/router';" : ''}
${config.features.state ? "import { useStore } from '@kalxjs/state';" : ''}
${config.features.api ? "import { useApi } from './api/useApi';" : ''}
${config.features.composition ? "import { useWindowSize } from './composables/useWindowSize';" : ''}
${config.features.performance ? "import { useLazyLoad } from './utils/performance/lazyLoad';" : ''}
${config.features.plugins ? "import { plugins } from './plugins';" : ''}
${config.features.ai ? "import { aiManager } from './ai/aiManager';" : ''}

export default defineComponent({
  name: 'App',
  setup() {
    console.log('App component setup called');

    // Initialize features based on configuration
    ${config.features.router ? `const router = useRouter();` : ''}
    ${config.features.state ? `const store = useStore();` : ''}
    ${config.features.api ? `const api = useApi({
      baseUrl: 'https://api.example.com'
    });` : ''}
    ${config.features.composition ? `const { width, height, isMobile } = useWindowSize();` : ''}
    ${config.features.plugins ? `// Register plugins
    plugins.register('logger', {
      install: () => console.log('Logger plugin installed')
    });` : ''}

    return {
      ${config.features.router ? 'router,' : ''}
      ${config.features.state ? 'store,' : ''}
      ${config.features.api ? 'api,' : ''}
      ${config.features.composition ? 'width, height, isMobile,' : ''}
    };
  },
  render() {
    console.log('App component render called');
    return h('div', { class: 'app', style: 'padding: 2rem; text-align: center;' }, [
      h('h1', { style: 'color: #333;' }, 'Welcome to KalxJS'),

      // Navigation if router is enabled
      ${config.features.router ?
      `h("nav", { style: "margin: 1rem 0; padding: 0.5rem; background-color: #f8f9fa; border-radius: 4px;" }, [
        h("a", { href: "/", style: "margin-right: 1rem; color: #4299e1; text-decoration: none;" }, "Home"),
        h("a", { href: "/about", style: "color: #4299e1; text-decoration: none;" }, "About")
      ]),` : ''}

      // Feature information section
      h('div', { style: 'margin-top: 1rem; padding: 1rem; background-color: #f8f9fa; border-radius: 8px; text-align: left;' }, [
        h('h2', { style: 'margin-top: 0; color: #2d3748;' }, 'Enabled Features:'),
        h('ul', { style: 'list-style-type: none; padding-left: 0;' }, [
          ${config.features.router ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Router')` : ''},
          ${config.features.state ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ State Management')` : ''},
          ${config.features.scss ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ SCSS Support')` : ''},
          ${config.features.sfc ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Single File Components (.klx)')` : ''},
          ${config.features.api ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ API Integration')` : ''},
          ${config.features.composition ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Composition API')` : ''},
          ${config.features.performance ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Performance Utilities')` : ''},
          ${config.features.plugins ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Plugin System')` : ''},
          ${config.features.ai ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ AI Features')` : ''},
          ${config.features.testing ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Testing')` : ''},
          ${config.features.linting ? `h('li', { style: 'margin: 0.5rem 0; padding: 0.5rem; background-color: #ebf8ff; border-radius: 4px;' }, 'âœ“ Linting')` : ''}
        ])
      ]),

      // Router view if router is enabled
      ${config.features.router ?
      `h("div", { style: "padding: 1rem; margin-top: 1rem; border-radius: 8px; background-color: white; box-shadow: 0 1px 3px rgba(0,0,0,0.1);" }, [h("router-view")])` :
      'h("p", { style: "margin-top: 1rem;" }, "Edit src/App.js to get started")'}
    ]);
  }
});`;

  files['vite.config.js'] = `import { defineConfig } from 'vite';
${config.features.sfc ? "import kalxSFC from '@kalxjs/compiler/vite-plugin';" : ''}

export default defineConfig({
  server: {
    port: 3000,
    open: true,
    cors: true
  },
  build: {
    outDir: 'dist',
    minify: 'terser',
    sourcemap: true
  },
  ${config.features.sfc ? `plugins: [
    kalxSFC() // Add support for .klx single file components
  ],` : ''}
  optimizeDeps: {
    include: [
      '@kalxjs/core',
      ${config.features.router ? "'@kalxjs/router'," : ''}
      ${config.features.state ? "'@kalxjs/state'," : ''}
      ${config.features.sfc ? "'@kalxjs/compiler'," : ''}
      ${config.features.ai ? "'@kalxjs/ai'," : ''}
      ${config.features.api ? "'@kalxjs/api'," : ''}
      ${config.features.composition ? "'@kalxjs/composition'," : ''}
      ${config.features.performance ? "'@kalxjs/performance'," : ''}
      ${config.features.plugins ? "'@kalxjs/plugins'," : ''}
    ]
  }
});`;

  // Add feature-specific files
  if (config.features.router) {
    files['src/router/index.js'] = `import { createRouter } from '@kalxjs/router';
import { h } from '@kalxjs/core';
import Home from '../views/Home.js';

// Create an About page component
const About = {
  name: 'About',
  render() {
    return h('div', { class: 'about', style: 'padding: 1rem;' }, [
      h('h2', { style: 'color: #4a5568;' }, 'About Page'),
      h('p', null, 'This is the about page content.'),
      h('p', null, 'KalxJS is a modern JavaScript framework for building user interfaces.')
    ]);
  }
};

// Create a NotFound page component
const NotFound = {
  name: 'NotFound',
  render() {
    return h('div', { class: 'not-found', style: 'padding: 1rem; text-align: center;' }, [
      h('h2', { style: 'color: #e53e3e;' }, '404 - Page Not Found'),
      h('p', null, 'The page you are looking for does not exist.'),
      h('a', {
        href: '/',
        style: 'color: #4299e1; text-decoration: none;'
      }, 'Go back to home')
    ]);
  }
};

export default createRouter({
  mode: 'history',
  routes: [
    {
      path: '/',
      component: Home
    },
    {
      path: '/about',
      component: About
    },
    {
      path: '*',
      component: NotFound
    }
  ]
});`;

    files['src/views/Home.js'] = `import { defineComponent, h } from '@kalxjs/core';
import Button from '../components/Button.js';

export default defineComponent({
  name: 'Home',
  setup() {
    console.log('Home component setup called');

    const handleClick = () => {
      console.log('Button clicked!');
      alert('Button clicked!');
    };

    return { handleClick };
  },
  render() {
    console.log('Home component render called');
    return h('div', { class: 'home', style: 'padding: 1rem;' }, [
      h('h2', { style: 'color: #4a5568;' }, 'Home Page'),
      h('p', null, 'This is the home page content.'),
      h(Button, {
        primary: true,
        text: 'Click me!',
        onClick: this.handleClick
      })
    ]);
  }
});`;
  }

  if (config.features.state) {
    files['src/store/index.js'] = `import { createStore } from '@kalxjs/state';

export default createStore({
  state: {
    count: 0,
    todos: [],
    loading: false,
    error: null
  },
  mutations: {
    increment(state) {
      state.count++;
    },
    decrement(state) {
      state.count--;
    },
    setCount(state, value) {
      state.count = value;
    },
    addTodo(state, todo) {
      state.todos.push(todo);
    },
    removeTodo(state, id) {
      state.todos = state.todos.filter(todo => todo.id !== id);
    },
    toggleTodo(state, id) {
      const todo = state.todos.find(todo => todo.id === id);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
    setLoading(state, status) {
      state.loading = status;
    },
    setError(state, error) {
      state.error = error;
    }
  },
  actions: {
    async fetchData({ commit }) {
      commit('setLoading', true);
      commit('setError', null);

      try {
        // Simulate API call
        await new Promise(resolve => setTimeout(resolve, 1000));
        commit('setCount', 42);
      } catch (error) {
        commit('setError', error.message);
      } finally {
        commit('setLoading', false);
      }
    }
  }
});`;
  }

  if (config.features.scss) {
    files['src/styles/main.scss'] = `/* Base styles */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background-color: #f7f8fa;
  color: #333;
  line-height: 1.6;
}

/* Layout */
.app {
  padding: 2rem;
  text-align: center;
  max-width: 1200px;
  margin: 0 auto;
}

.home {
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  padding: 2rem;
  margin-top: 1rem;
}

/* Typography */
h1 {
  font-size: 2.5rem;
  margin-bottom: 1rem;
  color: #2d3748;
}

h2 {
  font-size: 1.8rem;
  margin-bottom: 0.8rem;
  color: #4a5568;
}

p {
  margin-bottom: 1.5rem;
  color: #4a5568;
}

/* Buttons */
button {
  background-color: #4299e1;
  color: white;
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 1rem;
  transition: background-color 0.2s;
}

button:hover {
  background-color: #3182ce;
}

button:active {
  background-color: #2b6cb0;
}`;
  }

  // Write all files
  for (const [file, content] of Object.entries(files)) {
    await fs.writeFile(path.join(targetDir, file), content);
  }
}

async function installDependencies(targetDir, config) {
  const pkg = {
    name: config.projectName,
    version: '0.1.0',
    private: true,
    type: 'module',
    scripts: {
      "dev": "vite",
      "build": "vite build",
      "preview": "vite preview"
    },
    dependencies: {
      "@kalxjs/core": "^1.2.2"
    },
    devDependencies: {
      "vite": "^5.0.0"
    }
  };

  // Add feature-specific dependencies
  if (config.features.router) pkg.dependencies["@kalxjs/router"] = "^1.2.2";
  if (config.features.state) pkg.dependencies["@kalxjs/state"] = "^1.2.2";
  if (config.features.scss) pkg.devDependencies["sass"] = "^1.69.0";
  if (config.features.sfc) {
    pkg.dependencies["@kalxjs/compiler"] = "^1.2.2";
    pkg.devDependencies["@kalxjs/compiler-plugin"] = "^1.2.2";
  }
  if (config.features.ai) {
    pkg.dependencies["@kalxjs/ai"] = "^1.2.2";
  }
  if (config.features.api) {
    pkg.dependencies["@kalxjs/api"] = "^1.2.2";
  }
  if (config.features.composition) {
    pkg.dependencies["@kalxjs/composition"] = "^1.2.2";
  }
  if (config.features.performance) {
    pkg.dependencies["@kalxjs/performance"] = "^1.2.2";
  }
  if (config.features.plugins) {
    pkg.dependencies["@kalxjs/plugins"] = "^1.2.2";
  }

  // Write package.json
  await fs.writeJSON(path.join(targetDir, 'package.json'), pkg, { spaces: 2 });

  try {
    // Use child_process instead of execa
    const { execSync } = require('child_process');
    execSync('npm install', {
      cwd: targetDir,
      stdio: 'inherit',
      env: { ...process.env, FORCE_COLOR: true }
    });
  } catch (err) {
    throw new Error('Failed to install dependencies: ' + err.message);
  }
}

/**
 * Process template files and replace placeholders with configuration values
 * @param {string} targetDir - Target project directory
 * @param {Object} config - Project configuration
 */
async function processTemplates(targetDir, config) {
  const templateFiles = [
    'src/App.js',
    'src/main.js',
    'index.html',
    'README.md',
    'vite.config.js'
  ];

  // Add feature-specific template files
  if (config.features.router) {
    templateFiles.push('src/router/index.js');
    templateFiles.push('src/views/Home.js');
  }

  if (config.features.state) {
    templateFiles.push('src/store/index.js');
  }

  if (config.features.scss) {
    templateFiles.push('src/styles/main.scss');
  }

  if (config.features.api) {
    templateFiles.push('src/api/useApi.js');
  }

  if (config.features.composition) {
    templateFiles.push('src/composables/useWindowSize.js');
    templateFiles.push('src/composables/useLocalStorage.js');
  }

  if (config.features.performance) {
    templateFiles.push('src/utils/performance/lazyLoad.js');
    templateFiles.push('src/utils/performance/debounce.js');
  }

  if (config.features.plugins) {
    templateFiles.push('src/plugins/index.js');
    templateFiles.push('src/plugins/logger.js');
  }

  if (config.features.ai) {
    templateFiles.push('src/ai/aiManager.js');
    templateFiles.push('src/components/AITextGenerator.js');
  }

  if (config.features.sfc) {
    templateFiles.push('src/components/sfc/Card.klx');
  }

  // Process each template file
  for (const file of templateFiles) {
    const filePath = path.join(targetDir, file);

    // Skip if file doesn't exist
    if (!fs.existsSync(filePath)) {
      continue;
    }

    try {
      // Read file content
      let content = await fs.readFile(filePath, 'utf8');

      // Replace common placeholders
      content = content.replace(/\{\{projectName\}\}/g, config.projectName);
      content = content.replace(/\{\{version\}\}/g, '0.1.0');
      content = content.replace(/\{\{description\}\}/g, `A modern web application built with KalxJS`);

      // Replace feature flags
      Object.entries(config.features).forEach(([feature, enabled]) => {
        content = content.replace(new RegExp(`\\{\\{features\\.${feature}\\}\\}`, 'g'), enabled.toString());
      });

      // Process conditional blocks
      // Format: <!-- IF feature.name -->content<!-- ENDIF -->
      const conditionalRegex = /<!--\s*IF\s+features\.(\w+)\s*-->([\s\S]*?)<!--\s*ENDIF\s*-->/g;
      content = content.replace(conditionalRegex, (match, feature, block) => {
        return config.features[feature] ? block : '';
      });

      // Write processed content back to file
      await fs.writeFile(filePath, content, 'utf8');

    } catch (error) {
      console.error(`Error processing template file ${file}:`, error);
    }
  }

  // Process package.json separately (it's a JSON file)
  const packageJsonPath = path.join(targetDir, 'package.json');
  if (fs.existsSync(packageJsonPath)) {
    try {
      const packageJson = await fs.readJSON(packageJsonPath);

      // Update package.json fields
      packageJson.name = config.projectName;
      packageJson.description = `A modern web application built with KalxJS`;

      // Add custom scripts based on features
      if (config.features.testing) {
        packageJson.scripts.test = 'vitest run';
        packageJson.scripts['test:watch'] = 'vitest';
      }

      if (config.features.linting) {
        packageJson.scripts.lint = 'eslint src --ext .js,.klx';
        packageJson.scripts['lint:fix'] = 'eslint src --ext .js,.klx --fix';
      }

      // Write updated package.json
      await fs.writeJSON(packageJsonPath, packageJson, { spaces: 2 });

    } catch (error) {
      console.error('Error processing package.json:', error);
    }
  }
}

module.exports = create;
